
chapter03

go的优势，基于多线程的并发编程方式，在编写多进程和分布式程序方面也有很方便的标准库提供。

单用户操作系统，任务执行是串行。
多任务操作系统，运行多个程序，程序不需要使用CPU时挂起或中断。

多任务操作系统的问题：对系统资源的无限制抢夺和死锁现象会频繁发生。

并发编程思想提成一套理论，融合到编程语言，来按照这套理论来编写操作系统。

串行程序与并行程序

串行程序是指一组需要按顺序执行的指令列表。
并发程序是指两组或以上需要同时执行的指令或一组指令列表的综合体。
并行程序是指需要在并行的硬件上可以并发执行的程序（利用到多个硬件，比如多个CPU？）。

一个或多个共享的CPU

多元程序，是指操作系统内核支持多个串行程序复用多个CPU的方法。
多元处理，计算机中多个CPU共用一个存储器（内存）。

多元程序和多元处理是一个串行程序能并发甚至并行执行的基础支撑。

并发程序包含了所有可以实现并发行为的程序，是一个宽泛的概念，包括并行程序。

并发程序与并发系统：
并发程序是一个高内聚的程序，包含很多软件单元，程序之间通过协商好的协议这种方式通信，他们之间是松耦合的，可以看作是一个系统。

并发系统很可能是并行的（多个程序在不同的硬件之上运行），也叫并行系统，与之类似的系统是分布式系统。

串行程序是确定的，按顺序执行。
并发程序是不确定性的，所以每次运行，代码的执行路径可能都不一样。

并发程序的内部其实也是多个串行程序。他们之间需要交互/通信。
比如：对一个共享资源进行访问，就需要互相传递一些数据，这个时候就需要去协调这些串行程序的执行，就需要同步。
同步的作用是避免在并发访问共享资源的时候产生的一些冲突，保证数据有条不紊的传递。

同步的原则：
程序如果想访问资源，就必须先请求该资源先获取访问权，不需要访问的时候，就应该放弃对资源的访问权（释放资源）。
在同一时刻，资源只能被一个程序使用，一个程序去请求资源不应该导致其他正在访问资源的程序中断，应该等待释放后再进行请求。

传递数据是并发程序内部通信的一种方式（同步），还有异步的方式。
异步的方式：如果数据接收方没有准备好接收数据，请求方不会等待，会发送到通信缓存（一种共享的资源，数据结构=队列？，可被多个程序使用）中，数据接收方准备好了通过访问通信缓存来按顺序接收数据。

在现代操作系统中，类似上面每个并发程序内部串行程序间的通信，也有进程之间的通信（IPC），进程之间是通过协作来完成任务。

IPC的实现方式：
基于通信的IPC方法：
	以数据传送为手段：通过管道（pipe）传送字节流、通过消息队列（MQ）传送结构化的消息对象
	以共享内存为手段：共享内存区（shared memory），很快
基于信号的IPC方法：
	操作系统的信号机制（signal），唯一的异步IPC方法
基于同步的IPC方法：
	信号量（semaphore）

go支持的IPC方法有管道、信号、socket

进程的定义：
把一个程序运行起来了其实就变成一个进程了。
程序和进程是分别描述了一个程序的静态形态和动态特征。
进程是操作系统进行资源分配的一个基本单元。

父进程
子进程，是由父进程fork（一个系统调用函数）而来的，是父进程的副本。
fork之后，子进程会获得父进程的数据段、堆和栈的副本，和父进程共享代码段。
子进程对副本的修改对其他进程（父进程和兄弟进程）都是不可见的。

fork时候全盘copy父进程的资源副本是低效的，所以操作系统一般通过COW（copy on write）来提高进程创建效率。

刚创建的子进程，也可以通过exec（系统调用）一个新的程序，加载到自己的内存中，自己原先的数据段、堆、栈和代码段就会被替换掉。
子进程执行的就是刚加载替换来的新程序。

unix/linux中每个进程都有父进程，所以共同组成了一个树结构（进程树）。
内核启动进程就是这颗树的根结点，负责系统初始化操作，是所有进程的祖先。

pid：进程标识/进程ID，是操作系统分配的一个整型的数字，在操作系统中唯一，可重复使用。
ppid：父进程ID。

为什么要有pid？
操作系统内核为了管理进程，对进程的属性和行为进行详细的记录，包括优先级、状态、虚拟地址范围、各种访问权限等等。这些信息就被记录在文件描述符中。可以通过pid找到进程相关信息。
文件描述符：内核维持了一个pid=>文件描述符的映射关系？linux中一切皆文件，操作pid就是操作文件描述符/进程本身，比如kill pid就是杀掉一个进程，像进程发送信号，等等。

进程调度器：调度进程的程序。

进程有六种状态：
可运行（task_running, R）：进程立刻或正在运行中，运行时机不确定。
可中断的睡眠状态（S）：进程等待某个事件（网络连接或信号量），会放入等待队列，事件发生时一个或多个进程会被唤醒。
不可中断的睡眠状态（D）：不可打断，不会响应任何信号，等待某个特殊的事件，比如同步的IO操作（磁盘IO）。
暂停或跟踪/调试状态（T）：像进程发送SIGSTOP信号会变成该状态，再发送SIGCONT信号又会变成R状态。
僵尸状态（Z）：即将结束运行，进程占用的大部分资源都已经被回收，还有些未被删除，比如退出码和一些统计信息，父进程可能用的到，就只剩一个空壳。
退出状态（X）：进程退出，什么信息都不需要保留，可能是因为父进程忽略了SIGCHLD信号（子进程退出的时候会给父进程发送这个信号）或者父子进程已经分离了，退出状态的进程会干净利落退出，相关资源全部被系统自动回收。


进程的生命周期：

![](https://s3.bmp.ovh/imgs/2022/09/30/470c3fd7cb99245f.png)

进程空间：
用户空间：用户进程（程序的运行实例）所在空间，不能与硬件交互，用户进程无法直接访问内核空间。
内核空间：内核可以与硬件交互。
用户空间和内核空间都是操作系统对物理内存上做的一个划分。

内存：
内存区域的每个单元都有一个地址，用指针来标识和定位。
指针：一个正整数，用若干个二进制位组成。
内存单元的数量由CPU的字长决定，32位计算机有效标识2^32个，64位计算机有效标识2^64个。
内存寻址：通过指针来访问内存单元的操作叫内存寻址。
这个内存单元地址是虚拟地址，不是物理内存地址。
用虚拟地址标识的内存区域也叫虚拟内存地址空间/虚拟内存。
虚拟内存大小和物理内存大小无关，是由内核和CPU来维护这个映射关系的。

内核为每个用户进程分配虚拟内存，内核空间分配给内核专用。
每个用户进程的虚拟内存之间是隔离的，不可见，因为实际上映射在不同的物理内存上。

页（page）：内核将虚拟内存划分成若干页。
页框（page frame）：CPU将物理内存划分成若干页框。

进程的虚拟内存（页）和物理内存（页框）的关系：

![](https://s3.bmp.ovh/imgs/2022/09/30/6c6c2294d8d74ce5.png)

多页共享一个页框=共享内存区（一种IPC方法的实现基础）。
一些页没有映射到页框：该页没有数据或数据不需要被使用（数据被换出到磁盘/swap分区的概念）。

系统调用：
用户空间的程序（用户进程）无法直接操作硬件，内核空间的内核可以。
内核为了让用户进程使用操作系统的底层功能，会暴露出一些接口给用户进程，使用内核的功能（操作硬件等），就是用户进程和内核空间之间的一座桥梁，这些接口的行为就是系统调用。

系统调用和普通函数的区别：系统调用是内核的一部分。

内核态和用户态：
CPU被使用的两种状态。
用户态：CPU大部分时间都处于用户态，只能对用户空间进行访问，用户进程不能与内核接触。只有在系统调用时候，CPU从用户态切换到内核态，CPU进行对应的内核函数，并有权访问内核空间。系统调用完成，CPU切回用户态。相当于用户进程通过系统调用来使用内核功能。

CPU系统调用过程：

![](https://s3.bmp.ovh/imgs/2022/09/30/36032d1ef587c0bf.png)

系统调用服务例程=系统调用函数=内核函数


进程切换和进程调度：

进程间上下文切换：分时操作系统借助CPU，在不同进程之间进行切换。所以有多个进程同时运行的假象，所以叫多任务操作系统。
其实在同一时刻，CPU正在运行的进程只有一个。

切换CPU运行的进程的代价：
内核需要保存上个进程运行时的状态，重新运行时保证恢复到之前的运行时状态。
内核为了保证每个运行的进程都有被CPU运行的机会，需要考虑切换给哪个进程，什么时候切换，什么时候再换上等等。解决这个问题的方案和任务系统叫进程调度。

进程切换和进程调度是多个程序并发执行的基础。


进程之间通过相互配合共同完成一个任务，使用IPC技术。
IPC过程中的主要问题：对共享数据的操作（不论是多进程、多线程还是多CPU），牵扯到同步问题

进程间没有协调的情况：
两个进程会做重复的事情，因为时间跨度大，造成进程1的数据的更新，被进程2给更新回去了，是一种资源消耗。

底层运行机制：
竞态条件（race condition）：多个进程对同个资源进行访问，互相所造成的干扰就是竞态条件。
产生竞态条件的原因：进程在执行某个操作时候被中断了，等到再次运行时恢复如初，但是外界的环境已经在这极短时间内发生改变了。
如果保证进程的操作是原子操作（atomic operation）的话，可能就不会出现这个问题。

go语言的并发模型先进之处是减少了产生竞态条件的可能，尽可能把复杂的并发处理逻辑藏在运行时系统之下，让开发者有时间可精力去解决真正的业务问题。

临界区（critical section）：只能被串行化访问或执行的某个代码段或资源。
一组原子操作串行执行就是一个临界区。
临界区对是否可以被中断没有强制的规定。
系统调用都是原子操作，所以执行不会被中断。

原子操作需要芯片级（cpu）支持，能做到绝对的并发安全，为了保证原子操作的执行不会无法结束或无法中断，所以内核只提供二进制位和整数位的原子操作，只适合细颗粒度的简单操作。
go在cpu和各个操作系统之上实现了原子操作，使用 sync/atomic 包。


对于同步的方案，让串行执行的若干代码形成临界区的方式比原子操作更通用。
互斥（mutex）：保证只有一个进程或线程在临界区的做法就是互斥。
实现互斥方法的方式是排他原则
互斥方法的实现：信号量


管道（pipe）：单向/半双工通信方式。
只能用于父子进程或兄弟进程之间的通信。
ps aux | grep go








容器，填进去，defer函数结束执行前关闭监听器。

辅助函数

散弹式修改

缓冲读取器

请求数据块

多线程编程

POSIX线程的基本定义和概念
是go并发模型在linux系统下真正使用的内核接口
线程相关的重要问题：
线程间同步方法、线程安全性、线程本地存储

Go并发编程模型在底层是通过操作系统提供的线程库支撑的。


临界区/串行区域，同步机制
同步方法：
原子操作
互斥量
条件变量


信号
互斥量
条件变量

线程与KSE（内核调度实体）之间的关系：
用户级线程模型
内核级线程模型
两级线程模型


互斥（mutex）
线程在进入临界区之前，先锁定某个对象（互斥对象/互斥量），只有锁定成的线程才能进入，否则就阻塞。

已锁定和未锁定两种状态。
互斥量所有权的争夺：
锁定=获取
解锁=释放
阻塞的线程被唤醒再次尝试争夺

死锁




线程安全（thread-safe）

简约编程风格
工程哲学

Go的运行性能已经和很多系统级编程语言相差无几了。

计算机硬件的发展与摩尔定律吻合，每18个月，计算机的运行速度就翻一倍。
除了在算法和软件架构上的改进。多核扩展。
